package ch03_연산자;

/**
 * 1. 비트 논리 연산자는 bit 단위로 논리 연산을 수행한다.
 * 2. 0과 1이 피연산자가 되므로 2진수 0과 1로 저장되는 정수 타입만 피연산자가 될 수 있다.
 * 3. 논리 연산자의 종류
 * 		& (논리곱) - 두 비트 모두 1이면 1, 아니면 0
 * 		| (논리합) - 두 비트 모두 0이면 0, 아니면 1
 * 		^ (배타적 논리합) - 두 비트가 다르면 0, 같으면 1
 * 		~ (논리 부정) - 1이면 0, 0이면 1 -> 보수
 */
public class Ex04_비트연산자 {
    public static void main(String[] args) {

//      00000000 00000000 00000000 00101101     45
        //      00000000 00000000 00000000 00011001     25
        //---------------------------------------------------
        //   &  00000000 00000000 00000000 00001001     9  

        System.out.println("45 & 25 = " + (45 & 25)); // 9

        //      00000000 00000000 00000000 00101101     45
        //      00000000 00000000 00000000 00011001     25
        //---------------------------------------------------
        //   |  00000000 00000000 00000000 00111101     61  

        System.out.println("45 | 25 = " + (45 | 25)); // 61

        //      00000000 00000000 00000000 00101101     45
        //      00000000 00000000 00000000 00011001     25
        //---------------------------------------------------
        //   ^  00000000 00000000 00000000 00110100     52  
        
        System.out.println("45 ^ 25 = " + (45 ^ 25)); // 52

        //      00000000 00000000 00000000 00101101     45
        //---------------------------------------------------
        //   ~  11111111 11111111 11111111 11010010     -46  
        //      00000000 00000000 00000000 00101101     1의 보수
        //   +                                    1     2의 보수  
        //      00000000 00000000 00000000 00101110     46  
        //      11111111 11111111 11111111 11010001     1의 보수  
        //      11111111 11111111 11111111 11010010     +1 -> 2의 보수  

        System.out.println("~45 = " + (~45)); // -46
        System.out.println("-------------------------------");

        byte receiveData = -120;

        //      00000000 00000000 00000000 01111000     120
        //      11111111 11111111 11111111 10000111     1의 보수 (0<->1)
        //   +                                    1     2의 보수
        //--------------------------------------------------------
        //      11111111 11111111 11111111 10001000     -120


        
        // 방법1: 비트 논리곱 연산으로 Unsigned 정수 얻기
        //      11111111 11111111 11111111 10001000     -120
        //      00000000 00000000 00000000 11111111     255
        //---------------------------------------------------
        //   &  00000000 00000000 00000000 10001000     136  
        int unsignedInt1 = receiveData & 255;
        System.out.println(unsignedInt1); // 136

        // 방법2: 자바 API를 이용해서 Unsigned 정수 얻기
        int unsignedInt2 = Byte.toUnsignedInt(receiveData);
        System.out.println(unsignedInt2); // 136

        // 136은 1바이트에 담을 수 있지만 byte 범위를 넘는다
        // Java에서는 캐스팅 시 256을 기준으로 순환(wrap-around)됨
        // 136 - 256 = -120

        //      00000000 00000000 00000000 10001000     136
        //                                 10001000     -120
        //                                 01110111     1의보수
        //   +                                    1     2의보수
        //---------------------------------------------------
        //                                 01111000     120  
        int test = 136;
        byte btest = (byte) test;
        System.out.println(btest); // -120
    }
}
